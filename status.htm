<html>
<head>
<link rel="dns-prefetch" href="//otp-mta-prod.camsys-apps.com">
<link rel="preconnect" href="//otp-mta-prod.camsys-apps.com">
<link rel="dns-prefetch" href="//collector-otp-prod.camsys-apps.com">
<link rel="preconnect" href="//collector-otp-prod.camsys-apps.com">
<meta name="mobileoptimized" content="0">
<meta name="referrer" content="no-referrer">
</head>
<body>No javascript</body>
<!-- <script src=https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.17.4/lodash.js></script> -->
<script type="text/javascript">
mangleIndex={name:"mangleIndex"};
getStop.name = 'getStop';
parseRoutes.name = 'parseRoutes';
parseAlerts.name = 'parseAlerts';
var jsonp;

var url_routes = '//otp-mta-prod.camsys-apps.com/otp/routers/default/index/routes?apikey=Z276E3rCeTzOQEoBPPN4JCEc6GfvdnYE';
var url_alerts = '//collector-otp-prod.camsys-apps.com/realtime/gtfsrt/ALL/alerts?type=json&apikey=qeqy84JE7hUKfaI0Lxm2Ttcm6ZA0bYrP';
/* on Chrome, refresh does a 200 or 304 on stop.htm on GH Pages plus MTA call
   even though if I do a "back" then navigate back to stop.htm, no TCPIP traffic
   related to stop.htm because stop.htm is fetched from browser cache, sadly there
   seems to be no way to do a refresh or a replace without triggering network traffic
   so just implement a "Fast" path that does the AJAX call alone, kindda important
   for latency reasons on 2G networks, 200 always if .reload(1),
   304 typ if .reload(0)
*/
/* generate body top string once, its later used for fast refresh */
/* var t is "top" as in top of body (header) */
var t = '<a href=javascript:history.back()>Back</a> Refresh[<a href=javascript:getStop()>Fast</a> <a href=\"javascript:location.replace(\''
          +
/*STARTINSERTPATH*/
          (/status\.htm$/.test(location.pathname) ? "status_.htm" : "status.htm")
/*ENDINSERTPATH*/
          +'\')">Slow</a>] <a href='+url_routes+'>RawR</a> <a href='+url_alerts+'>RawA</a><br>';

getStop();

function getStop() {
getJSON(url_routes);
getJSON(url_alerts,1);
document.body.innerHTML = t; /*t=top*/
}

//text includes [] chars usually, if route blank, text is route
function mkSubFontTag(text, route) {
  var c =
/*STARTCOLOR*/
{"1":"EE352E","2":"EE352E","3":"EE352E","4":"00933C","5":"00933C","5X":"00933C","6":"00933C","6X":"00A65C","7":"B933AD","7X":"B933AD","A":"2850AD","B":"FF6319","C":"2850AD","D":"FF6319","E":"2850AD","F":"FF6319","FX":"FF6319","G":"6CBE45","GS":"6D6E71","J":"996633","L":"A7A9AC","M":"FF6319","N":"FCCC0A","Q":"FCCC0A","R":"FCCC0A","W":"FCCC0A","Z":"996633"}
/*ENDCOLOR*/
  [route||text];
  return c ?'<font color='+c+'>'+text+'</font>':text;
}

if (typeof Object.assign != 'function') {
  Object.assign = function (target, varArgs) { // .length of function is 2
  'use strict';
  if (target == null) { // TypeError if undefined or null
    throw new TypeError('Cannot convert undefined or null to object');
  }

  var to = Object(target);

  for (var index = 1; index < arguments.length; index++) {
    var nextSource = arguments[index];

    if (nextSource != null) { // Skip over if undefined or null
      for (var nextKey in nextSource) {
        // Avoid bugs when hasOwnProperty is shadowed
        if (Object.prototype.hasOwnProperty.call(nextSource, nextKey)) {
          to[nextKey] = nextSource[nextKey];
        }
      }
    }
  }
  return to;
}
}

if (!String.prototype.includes) {
  String.prototype.includes = function(search, start) {
    'use strict';
    if (typeof start !== 'number') {
      start = 0;
    }

    if (start + search.length > this.length) {
      return false;
    } else {
      return this.indexOf(search, start) !== -1;
    }
  };
}

if (!Array.prototype.includes) {
  Array.prototype.includes = function (obj) {
    var newArr = this.filter(function (el) {
      return el == obj;
    });
    return newArr.length > 0;
  }
}

if (!Object.keys) Object.keys = function(o) {
  if (o !== Object(o))
    throw new TypeError('Object.keys called on a non-object');
  var k=[],p;
  for (p in o) if (Object.prototype.hasOwnProperty.call(o,p)) k.push(p);
  return k;
}

if (!Array.prototype.findIndex) {
  Array.prototype.findIndex = function (callback) {
      if (this === null) {
        throw new TypeError('Array.prototype.findIndex called on null or undefined');
      } else if (typeof callback !== 'function') {
        throw new TypeError('callback must be a function');
      }
      var list = Object(this);
      // Makes sures is always has an positive integer as length.
      var length = list.length >>> 0;
      var thisArg = arguments[1];
      for (var i = 0; i < length; i++) {
        if (callback.call(thisArg, list[i], i, list)) {
          return i;
        }
      }
      return -1;
    }
}

if (!Array.prototype.find) {
  Array.prototype.find = function(callback) {
  if (this === null) {
    throw new TypeError('Array.prototype.find called on null or undefined');
  } else if (typeof callback !== 'function') {
    throw new TypeError('callback must be a function');
  }
  var list = Object(this);
  // Makes sures is always has an positive integer as length.
  var length = list.length >>> 0;
  var thisArg = arguments[1];
  for (var i = 0; i < length; i++) {
    var element = list[i];
    if ( callback.call(thisArg, element, i, list) ) {
      return element;
    }
  }
}
}

if (!Array.prototype.filter) {
  Array.prototype.filter = function(fun /*, thisp*/) {
    'use strict';

    if (this == null) {
      throw new TypeError();
    }

    var t = Object(this),
        len = t.length >>> 0,
        res, thisp, i, val;
    if (typeof fun !== 'function') {
      throw new TypeError();
    }

    res = [];
    thisp = arguments[1];
    for (i = 0; i < len; i++) {
      if (i in t) {
        val = t[i]; // in case fun mutates this
        if (fun.call(thisp, val, i, t)) {
          res.push(val);
        }
      }
    }

    return res;
  };
}

// Production steps of ECMA-262, Edition 5, 15.4.4.19
// Reference: http://es5.github.com/#x15.4.4.19
if (!Array.prototype.map) {
  Array.prototype.map = function (callback, thisArg) {

      var T,
      A,
      k;

      if (this == null) {
        throw new TypeError(" this is null or not defined");
      }

      // 1. Let O be the result of calling ToObject passing the |this| value as the argument.
      var O = Object(this);

      // 2. Let lenValue be the result of calling the Get internal method of O with the argument "length".
      // 3. Let len be ToUint32(lenValue).
      var len = O.length >>> 0;

      // 4. If IsCallable(callback) is false, throw a TypeError exception.
      // See: http://es5.github.com/#x9.11
      if (typeof callback !== "function") {
        throw new TypeError(callback + " is not a function");
      }

      // 5. If thisArg was supplied, let T be thisArg; else let T be undefined.
      if (thisArg) {
        T = thisArg;
      }

      // 6. Let A be a new array created as if by the expression new Array(len) where Array is
      // the standard built-in constructor with that name and len is the value of len.
      A = new Array(len);

      // 7. Let k be 0
      k = 0;

      // 8. Repeat, while k < len
      while (k < len) {

        var kValue,
        mappedValue;

        // a. Let Pk be ToString(k).
        //   This is implicit for LHS operands of the in operator
        // b. Let kPresent be the result of calling the HasProperty internal method of O with argument Pk.
        //   This step can be combined with c
        // c. If kPresent is true, then
        if (k in O) {

          // i. Let kValue be the result of calling the Get internal method of O with argument Pk.
          kValue = O[k];

          // ii. Let mappedValue be the result of calling the Call internal method of callback
          // with T as the this value and argument list containing kValue, k, and O.
          mappedValue = callback.call(T, kValue, k, O);

          // iii. Call the DefineOwnProperty internal method of A with arguments
          // Pk, Property Descriptor {Value: mappedValue, : true, Enumerable: true, Configurable: true},
          // and false.

          // In browsers that support Object.defineProperty, use the following:
          // Object.defineProperty(A, Pk, { value: mappedValue, writable: true, enumerable: true, configurable: true });

          // For best browser support, use the following:
          A[k] = mappedValue;
        }
        // d. Increase k by 1.
        k++;
      }

      // 9. return A
      return A;
    }
}

if (!Array.prototype.forEach) {
  Array.prototype.forEach = function (fn, scope) {
    'use strict';
    var i,
    len;
    for (i = 0, len = this.length; i < len; ++i) {
      if (i in this) {
        fn.call(scope, this[i], i, this);
      }
    }
  };
}

if (!Date.now) {
  Date.now = function now() {
    return new Date().getTime();
  };
}

if (!Date.prototype.toISOString) {
  Date.prototype.toISOString = function () {
    var m = 1 + this.getMonth()
      var d = this.getDay()
      return this.getFullYear() + "-" + (m < 10 ? '0' + m : m) + "-" + (d < 10 ? '0' + d : d)
  }
}

/* inlined
const BANNED_XBUS_ROUTE_TYPE = 702;
const NEW_HAVEN_BRANCHES = ['MNR:4', 'MNR:5', 'MNR:6'];
const HARLEM_BRANCHES = ['Wassaic'];
const WEIRD_RAIL_LINES = [{
  id: "MNR:Wassaic",
  agency: "MNR",
  color: "0039A6",
  inService: true,
  mode: "RAIL",
  longName: "Wassaic",
  routeId: "MNR_Wassaic",
  routeType: 2
}]
*/

/*lodash shims are MINIMALLY compliant to get this work*/
_ = {};
_.findIndex = function (array,f) {return array.findIndex(f)}
_.find = function (array, f) {
  var key = Object.keys(f)[0],
  value = f[key];
  return array.find(function (element) {
    return typeof element === 'object' && element[key] == value ? 1 : 0
  })
}
_.each = function (array, f) {
  array.forEach(f)
}
_.filter = function (array, f) {
  if(typeof f === 'function')
    return array.filter(f);
  else {
    var key = Object.keys(f)[0],
    value = f[key];
    return array.filter(function (element) {
      return typeof element === 'object' && element[key] == value ? 1 : 0
    })
  }
}
mapper = {};
function buildSubwayRoute (data) {
  var subwayLines = data
    .filter(function (subway) {return subway.mode.toUpperCase() === 'SUBWAY'})
    .filter(function (subway) {return subway.id.includes('MTA')})

  var routeDetails = [];

  // start by sorting the subwayLines returned (by name)
  subwayLines.sort(function (l1, l2) {
  //IE 6 and below don't allow - op on strings, throws error
  //- op is MTA orig logic
    return isNaN(l1.shortName) || isNaN(l2.shortName)
      ? 0 : l1.shortName - l2.shortName;
  });

  subwayLines.forEach(function (subwayLine) {
    var route;
    var name = subwayLine.shortName;

    // check to see if a previous, associated, non-express line is found given the current express line
    if (name.substr(name.length - 1, name.length) === 'X') {
      // if so, set the route given the previously set non-express route
      route = _.find(routeDetails, {
        name: name.substr(0, name.indexOf('X'))
      });
    }

    // check to see if a route was found...
    if (!route) {
      // if not, initialize one and add it to the routeDetails array
      routeDetails.push(route = {
        agency: subwayLine.id.split(":")[0],
        agencyId: subwayLine.id.split(":")[0],
        name: subwayLine.id.split(":")[1],
        mode: 'SUBWAY',
        color: subwayLine.color,
        sortOrder: subwayLine.sortOrder,
        id: subwayLine.id.split(":")[1]
      });
    } else {
      // otherwise, first set the containsExpress variable / flag
      route.containsExpress = true;
    }
  });

  // Finish up by sorting by sort order
  routeDetails.sort(function (l1, l2) {
    return l1.sortOrder - l2.sortOrder;
  });

  return routeDetails;
}

function buildBusRoute (stopData) {
  var mapRoutes = stopData
    .filter(function (busRoute) {return busRoute.mode.toUpperCase() === 'BUS'})
    .filter(function (busRoute) {return !!~busRoute.id.indexOf('MTA')})
    .map(function (stop) {
      var agency = stop.agencyName === 'MTA New York City Transit' ? 'MTA NYCT' : 'MTABC';
      var routeId = agency+"_"+stop.id.split(':')[1];

      return Object.assign({
        agency: agency,
        inService: true,
/* const BANNED_XBUS_ROUTE_TYPE = 702; */
        isExpressBus: (stop.routeType === 702),
        routeId: routeId,
        route: stop.shortName
      }, stop)
    })
  return mapRoutes
}

function buildRailRoute (data) {
  var railLines = data
    .filter(function (railLine) {return railLine.mode.toUpperCase() === 'RAIL'})
    .filter(function (railLine) {return railLine.id.includes('LI') || railLine.id.includes('MNR')})
    .concat(/* WEIRD_RAIL_LINES */
    [{
  id: "MNR:Wassaic",
  agency: "MNR",
  color: "0039A6",
  inService: true,
  mode: "RAIL",
  longName: "Wassaic",
  routeId: "MNR_Wassaic",
  routeType: 2
}]
    )
    .map(function (railLine) {
      var agency = railLine.id.includes('LI') ? 'LI' : 'MNR';
      railLine.inService = true;
      railLine.agency = agency;
      railLine.agencyId = agency;
      railLine.route = railLine.longName;
      railLine.routeId = railLine.routeId ? railLine.routeId : railLine.id.replace(":", "_");
      railLine.mode = "RAIL";
      railLine.shortName = railLine.longName;
      return railLine;
    });

  // start by sorting all rail lines alphabetically
  railLines.sort(function (line1, line2) {
    if (line1.longName < line2.longName) {  //sort string alphabetically
      return -1;
    } else /*if (line1.route > line2.route)*/ {
      return 1;
    }
  });

  // remove all kubes from the railLines array that are contained within the NEW_HAVEN_BRANCHES constant (array)
  var newHavenBranches = []
  if (
  /* Array.isArray(NEW_HAVEN_BRANCHES) && */
  railLines instanceof Array && railLines.length) {
    for (var i = 0; i < railLines.length; i++) {
      if (/*NEW_HAVEN_BRANCHES.*/ ['MNR:4', 'MNR:5', 'MNR:6'].includes(railLines[i].id)) {
        newHavenBranches.push(railLines[i])
        railLines.splice(i, 1)
        i--
      }
    }
  }

  // get the index of the 'New Haven' line
  var newHavenLineIndex = _.findIndex(railLines, function (railLine) {
    return railLine.id === 'MNR:3';
  });

  // remove all kubes from the railLines array that are contained within the HARLEM_BRANCHES constant (array)
  var harlemBranches = []
  if ( /* Array.isArray(HARLEM_BRANCHES) && */
    railLines instanceof Array && railLines.length) {
    for (var i = 0; i < railLines.length; i++) {
      if (/*HARLEM_BRANCHES.*/['Wassaic'].includes(railLines[i].longName)) {
        harlemBranches.push(railLines[i])
        railLines.splice(i, 1)
        i--
      }
    }
  }
  // get the index of the 'Harlem' line
  var harlemLineIndex = _.findIndex(railLines, function (railLine) {
    return railLine.id === 'MNR:2';
  });

  // place the (sorted) newHavenBranches into the railLines array directly AFTER the newHavenLineIndex and return
  var railLinesSorted = railLines.slice(0, newHavenLineIndex + 1).concat(newHavenBranches).concat(railLines.slice(newHavenLineIndex + 1));
  return railLinesSorted.slice(0, harlemLineIndex + 1).concat(harlemBranches).concat(railLinesSorted.slice(harlemLineIndex + 1));
}


mapper.buildServiceRoutes = function (response) {
  var routes = {
    busRoutes: buildBusRoute(response),
    railLines: buildRailRoute(response),
    subwayLines: buildSubwayRoute(response),
    lastUpdated: new Date()
  };

  return routes;
}

function mergeStatii (routes, statii) {
  var routesWithStatus = [];

  function getSummary (status) {
    var alert = "No Status Summary";

    if (status.alert['transit_realtime.mercury_alert']) {
      alert = status.alert['transit_realtime.mercury_alert'].alert_type;
    }

    return alert;
  }

  function getDates (status) {
    var startDate = null;
    var endDate = null;
    var creationDate = null;

    if (status.alert.active_period) {
      var currentTime = Math.round(Date.now() / 1000);
      var activePeriod = false;

      status.alert.active_period.forEach(function (period) {
        if (period.start) {
          if (currentTime > period.start) {
            activePeriod = period;
          }

          if (period.end && currentTime > period.end) {
            activePeriod = false;
          }

          if (activePeriod) {
            return;
          }
        }
      });

      startDate = activePeriod.start ? new Date(activePeriod.start * 1000).toISOString() : null;
      endDate = activePeriod.end ? new Date(activePeriod.end * 1000).toISOString() : null;
    }

    if (status.alert['transit_realtime.mercury_alert']) {
      creationDate = new Date(status.alert['transit_realtime.mercury_alert'].created_at * 1000).toISOString();
    }

    return {
      startDate: startDate,
      endDate: endDate,
      creationDate: creationDate
    }
  }

  function getDescription (status) {
    var description = false;

    if (status.alert.description_text) {
      status.alert.description_text.translation.forEach(function (translation) {
        if (translation.language === 'en-html') {
          description = translation.text;
        }
      })

      if (description) {
        return description;
      }

      if (!description) {
        status.alert.description_text.translation.forEach(function (translation) {
          if (translation.language === 'en') {
            description = translation.text;
          }
        })
      }

      if (description) {
        return description;
      }

      if (!description) {
        status.alert.description_text.translation.forEach(function (translation) {
          if (translation.language === '') {
            description = translation.text;
          }
        })
      }

      if (description) {
        return description;
      }
    }

    return description;
  };

  function getHeader (status) {
    var header = false;

    if (status.alert.header_text) {
      status.alert.header_text.translation.forEach(function (translation) {
        if (translation.language === 'en-html') {
          header = translation.text;
        }
      })

      if (header) {
        return header;
      }

      status.alert.header_text.translation.forEach(function (translation) {
        if (translation.language === 'en') {
          header = translation.text;
        }
      })

      if (header) {
        return header;
      }

      status.alert.header_text.translation.forEach(function (translation) {
        if (translation.language === '') {
          header = translation.text;
        }
      })

      if (header) {
        return header;
      }
    }

    return header;
  };

  function getPriority (entity) {
    var priority = -10;

    if (entity['transit_realtime.mercury_entity_selector']) {
      if (entity['transit_realtime.mercury_entity_selector'].sort_order) {
        priority = entity['transit_realtime.mercury_entity_selector'].sort_order.split(':');
        priority = priority[2] ? priority[2] * 1 : 100;
      }
    }

    return priority;
  };

  // Reduce the number of statii to only those that are current
  var currentStatii = statii.filter(function (status) {
    var isCurrent = false;

    try {
      if (status.alert.active_period && status.alert['transit_realtime.mercury_alert'] && status.alert['transit_realtime.mercury_alert'].alert_type) {
        var hasBeforeActive = status.alert['transit_realtime.mercury_alert'].hasOwnProperty('display_before_active');

        var currentTime = Math.round(Date.now() / 1000);
        var isPlannedWork = status.id.includes('planned_work');

        if (isPlannedWork && !hasBeforeActive) {
          isCurrent = false;
        } else {
          status.alert.active_period.forEach(function (period) {
            if (period.start && !isCurrent) {
              var startTime = period.start;

              if (hasBeforeActive) {
                startTime = startTime - status.alert['transit_realtime.mercury_alert'].display_before_active;
              }

              if (currentTime > startTime) {
                isCurrent = true;
              }

              if (period.end && currentTime > period.end) {
                isCurrent = false;
              }
            }
          });
        }
      }
    } catch (e) {
      console.log(e);
    }

    return isCurrent;
  });

  routes.forEach(function (route) {
    var key = route.mode === 'SUBWAY' ? route.name : route.shortName;
    var searchKeys = [];
    var statii = [];
    var confirmAgency = true;
    var postedIds = [];

    if (route.mode === 'RAIL') {
      if (route.routeId.includes('NJT')) {
        key = route.routeId.replace('_', ':');
      } else {
        key = route.routeId.split('_')[1];
      }
    }

    if (route.mode === 'BUS') {
      key = route.id.split(':')[1];
    }

    key = key.toLowerCase();

    searchKeys.push(key);

    if (route.mode === 'BUS') {
      searchKeys.push(key+'-ltd');
      confirmAgency = false;
    }

    currentStatii.forEach(function (status) {
      if (status.alert) {
        if (status.alert.informed_entity) {
          status.alert.informed_entity.forEach(function (entity) {

            var route_id = null;
            var agency_id = null;
            var direction_id = 1;
            var correctAgency = true;

            if (entity.route_id) {
              route_id = entity.route_id;
            }

            if (entity.agency_id) {
              agency_id = entity.agency_id;
            }

            if (entity.trip) {
              if (entity.trip.route_id) {
                route_id = entity.trip.route_id;
                direction_id = entity.trip.direction_id;
              }
            }

            if (confirmAgency) {
              correctAgency = agency_id == route.agency;
            }

            route_id = route_id ? route_id.toLowerCase() : '';

            if (searchKeys.includes(route_id) && correctAgency && !postedIds.includes(status.id)) {
              // See MNR alerts in the console as they come in.
              // if (route.agency === "MNR") {
              //   console.log('line-list-js status.alert.informed_entity MNR ', route_id, status)
              // }
              try {
                var summary = getSummary(status);
                var description = getDescription(status);
                var header = getHeader(status);
                var priority = getPriority(entity);
                var dates = getDates(status);

                var statusItem = Object.assign({
                  id: status.id,
                  statusSummary: summary,
                  statusDescription: description,
                  statusTitle: header,
                  priority: priority,
                  direction: direction_id,
                  originalStatus: status
                  },dates);

                statii.push(statusItem);
                postedIds.push(status.id);
              } catch (e) {
                console.log(status.id, e);
              }
            }
          });
        }
      }
    });

    if (statii.length > 0) {
      route.statusDetails = statii;
    }

    routesWithStatus.push(route);
  });

  return routesWithStatus;
};

function groupedLines (){
  var statii = {}
  var prioritizedLines = []

  for (var i = 0; i < this.lines.length; i++){
    // Sort statii by priority
    this.lines[i].statusDetails.sort(function (a,b) {
      return b.priority - a.priority
    });

    var status = this.toDashedCase(this.lines[i].statusDetails[0].statusSummary)

    if (!statii[status]) {
      statii[status] = {
        status: this.lines[i].statusDetails[0].statusSummary,
        priority: this.lines[i].statusDetails[0].priority
      }
    }

    if (!statii[status].lines){
      statii[status].lines = []
    }

    statii[status].lines.push(this.lines[i])
  }
  var stat =''
  for(stat in statii) {
    prioritizedLines.push(statii[stat])
  }

  if (prioritizedLines.length > 0) {
    prioritizedLines.sort(function (a,b) {
      return b.priority - a.priority
    })
  }

  return prioritizedLines
}

function sortSubwayLines (routes) {
  routes.sort(function (rd1, rd2) {
    return rd1.sortOrder - rd2.sortOrder
  })
}

function SET_SUBWAY_LINES (state, res) {
    var lines = res.subwayLines
    state.lastUpdated = res.lastUpdated

    if (state.subwayLines.length || state.goodServiceLines.length) {
      _.each(lines, function (route) {
        // find if the line is part of good service or delays / service change / planned work
        var previousGoodServiceRouteIndex = _.findIndex(state.goodServiceLines, { id: route.id })
        var previousServiceDetailsRouteIndex = _.findIndex(state.subwayLines, { id: route.id })
        // remove the line from previous list
        if (previousGoodServiceRouteIndex > -1) {
          state.goodServiceLines.splice(previousGoodServiceRouteIndex, 1)
        } else if (previousServiceDetailsRouteIndex > -1) {
          state.subwayLines.splice(previousServiceDetailsRouteIndex, 1)
        }
        // add the line to new list based on status
        if (route.statusDetails) {
          state.subwayLines.push(route)
        } else {
          state.goodServiceLines.push(route)
        }
      })
    } else {
      // add lines for the first time
      _.each(lines, function (route) {
        if (route.statusDetails) {
          state.subwayLines.push(route)
        } else {
          state.goodServiceLines.push(route)
        }
      })

      if (res.subwayLines.length) {
        state.allSubwayLines = res.subwayLines
      }
    }

    sortSubwayLines(state.subwayLines)
    sortSubwayLines(state.goodServiceLines)
  }
function SET_BUS_ROUTES(state, res) {
    var busRoutes = res.busRoutes;

    var alertedBuses = []

    busRoutes.forEach(function (route) {
      if (route.statusDetails) {
        route.statusDetails.sort(function (a, b) {
          return b.priority - a.priority
        })
        alertedBuses.push(route)
      }

    })
    state.alertedBuses = alertedBuses


    if (state.busRoutes.length) {
      _.each(busRoutes, function (route) {
        var busRoute = _.find(state.busRoutes, { routeId: route.routeId })
        if (busRoute) {
          busRoute.statusDetails = route.statusDetails

        }
      })
      // console.log('line-list state.busRoutes ', state.busRoutes)
    } else {
      // console.log('line-list no state yet busRoutes ', busRoutes)
      state.busRoutes = busRoutes
    }
  }
function SET_RAIL_LINES(state, res) {
    var lines = res.railLines;
    /* jQuery(document).trigger('trigCheck'); bulk88 removed */

    lines.forEach(function (line) {
      if (line.statusDetails) {
        line.statusDetails.sort(function (a, b) {
          return b.priority - a.priority
        })
      }
    })

    if (state.mnrLines.length && state.longIslandLines.length) {
      _.each(lines, function (line) {
        if (line.agency === 'LI') {
          var liLine = _.find(state.longIslandLines, { routeId: line.routeId })
          if (liLine) {
            liLine.statusDetails = line.statusDetails
          }
        } else if (line.agency === 'MNR' || line.agency === 'NJT') {
          var mnrLine = _.find(state.mnrLines, { routeId: line.routeId })
          if (mnrLine) {
            mnrLine.statusDetails = line.statusDetails
          }
        }
      })
    } else {
      state.longIslandLines = _.filter(lines, { agency: 'LI' })
      state.mnrLines = _.filter(lines, function (line) { return line.agency === 'MNR' || line.agency === 'NJT' })
    }
  }
function toDashedCase(str){
  return str.toLowerCase().replace(/\s/g, '-')
}
function noPTag(str) {
  if(typeof str == 'string') {
    //some notices include these at the end, after the global P tag we are trying to remove
    str = str.replace(/(<p style="min-height:10px"><\/p>|<p><\/p>)+$/g,'');
    if (str.indexOf('<p>') === 0 && str.indexOf('</p>', str.length - 4) !== -1) {
      return str.substring(3, str.length-4);
    }
  }
  return str;
}
function hasDuration(alert) {
  return alert.originalStatus.alert["transit_realtime.mercury_alert"]
  .human_readable_active_period;
}
function getDurations(alert) {
  /* originally picks en-html, then en, then nothing
  return [
  this.getText(
  alert.alert["transit_realtime.mercury_alert"]
  .human_readable_active_period.translation
  ),
  ];
   */
  return alert.originalStatus.alert["transit_realtime.mercury_alert"].human_readable_active_period.translation[0].text;
}

function getStatus(obj) {
  if (obj.inService) {
    if (obj.statusDetails && obj.statusDetails.length) {
      // console.log('rail-line-list-vue obj.statusDetails[0].statusSummary', obj.statusDetails[0].statusSummary)
      return obj.statusDetails[0].statusSummary;
    }
    return "On or Close";
  } else {
    // if an alert shows up for out of service line - currently will not happen
    if (obj.statusDetails && obj.statusDetails.length) {
      return obj.statusDetails[0].statusSummary;
    } else {
      return "No Scheduled Service";
    }
  }
}

function emitRRStatus(name, lines) {
  var h = '';
  if (lines.length) {
    h += '<hr>' + name + '<br>';
    h += lines.map(function (route) {
      var has_alert = route.statusDetails && route.statusDetails.length;
      return '<hr>' + (has_alert ? '<details><summary>' : '') + '<font color=' + route.color + '>' + route.route + '</font>' + ' ' + getStatus(route) + (has_alert ? '</summary>' + route.statusDetails.map(function (statusDetail) {
          return '<b>' + statusDetail.statusSummary + '</b>'
           + '<br>' + noPTag(statusDetail.statusTitle)
           + (hasDuration(statusDetail) ? '<br>' + getDurations(statusDetail) : '')
           + '<br>' + (statusDetail.statusDescription ? noPTag(statusDetail.statusDescription) : '')
        }).join('<hr>') + '</details>' : '')
    }).join('');
  }
  return h;
}

var allRoutes;
var alertsResp;
function parseRoutes(r) { /*r=resp*/
  /*injection IDC, < IE 8 dont have JSON obj & not gonna load 3rd party*/
  /* r.contents is JSONP */
  allRoutes = mapper.buildServiceRoutes(typeof (r = r.contents || r) === 'object' ? r : this.JSON?JSON.parse(r):eval('0,' + r))
  if (alertsResp)
    drawHTML();
}

function parseAlerts(r){/*r=resp*/
  /*injection IDC, < IE 8 dont have JSON obj & not gonna load 3rd party*/
  /* r.contents is JSONP */
  alertsResp = (typeof (r = r.contents || r) === 'object' ? r : this.JSON?JSON.parse(r):eval('0,' + r)).entity;
  if(allRoutes)
    drawHTML();
}
function drawHTML() {
      var h=(new Date()).toLocaleTimeString('en-US')+(jsonp ? ' via JSONP' : ' via CORS') + "<br>",i,route,o;
      var statii = alertsResp;
      var allStatii = {
        busRoutes: mergeStatii(allRoutes.busRoutes, statii),
        railLines: mergeStatii(allRoutes.railLines, statii),
        subwayLines: mergeStatii(allRoutes.subwayLines, statii)
      };
      var state = {
        mnrLines: [],
        busRoutes: [],
        subwayLines: [],
        componentRoutes: [],
        longIslandLines: [],
        goodServiceLines: [],
        favorites: null,
        lastUpdated: null,
        lineListError: null,
        allSubwayLines: null,
        subwayLineGroups: null,
        serviceStatusLoading: false,
        alertedBuses: []
      }

      SET_SUBWAY_LINES(state, allStatii);
      SET_RAIL_LINES(state, allStatii);
      SET_BUS_ROUTES(state, allStatii);
      var groupedByStatusLines = groupedLines.call({
        lines: state.subwayLines,
        toDashedCase: toDashedCase
      });

      for (i=0; i < groupedByStatusLines.length; i++) {
        var linearr = groupedByStatusLines[i];
        h += '<hr>' + linearr.status + '<br>';
        linearr = linearr.lines;
        for (o=0; o < linearr.length; o++) {
          route = linearr[o];
          //if(route.name=='SI') {debugger;}
          h+='<details><summary>'+mkSubFontTag('['+route.name+']', route.name)+'</summary>';
          h += route.statusDetails.map(function (statusDetail) {
            return '<b>'+statusDetail.statusSummary+'</b>'
            + '<br>' + noPTag(statusDetail.statusTitle).replace(/\[(\w+)\]/g, mkSubFontTag)
            + (hasDuration(statusDetail)?'<br>'+getDurations(statusDetail):'')
            + '<br>' + (statusDetail.statusDescription ? noPTag(statusDetail.statusDescription).replace(/\[(\w+)\]/g, mkSubFontTag):'')
          }).join('<hr>');
          h+='</details>';
        }
      }

      groupedByStatusLines = state.goodServiceLines;
      if(groupedByStatusLines.length) {
        h += '<hr>No Active Alerts<br>';
        for (i=0; i < groupedByStatusLines.length; i++) {
          route = groupedByStatusLines[i].name;
          h+=mkSubFontTag('['+route+']', route)+' ';
        }
      }

      h += emitRRStatus('Metro-North Railroad',state.mnrLines);
      h += emitRRStatus('Long Island Rail Road',state.longIslandLines);

    document.body.innerHTML += h;
    alertsResp = void 0;
    allRoutes = void 0;
}
function getJSON(url, alertFlag, addIMS) {
/*Firefox, Opera, IE7, and other browsers will use the native object*/
/*IE 5 and 6 will use the ActiveX control*/
    var x = this.XMLHttpRequest ? new XMLHttpRequest() : new ActiveXObject("Microsoft.XMLHTTP");
    try {
        /*throw(0);*/
        /* on Fast refresh, on CORS enabled browsers, a traintime.lirr.org XHR req
          will happen over network, once browser sees no Access Control header
          it will "fail" the req to the page, then the page does the JSONP network
          request, stop this double request thing to save network traffic after CORS
          fails the 1st time, the server wont magically get the header one minute.
          Once CORS fails once, it will never succeed on that particular client, so
          never try a CORS request again.
          Browsers without CORS like Opera 10, fail the XHR req, instantly, client
          side, without network traffic.*/
        if(jsonp) throw(0);
        /*open() can fire errors events or throw exceptions*/
        x.open('get', url, 1);
        try {
          x.responseType = 'json';
        } catch (e) {
          //old chromes throw "SYNTAX_ERR: DOM Exception 12" if no XHR JSON
        }
        /* handler assignment can't be factored to root or IE6 desktop and IE6 mobile
          wont drawn train times using "Fast" beyond the 1st/initial page load
          and only "Slow" works
          http://keelypavan.blogspot.com/2006/03/reusing-xmlhttprequest-object-in-ie.html*/
        x.onreadystatechange = function ()
{
    if (x.readyState == 4)
    {
            if (x.status == 200)
            {   /* IE 6 cache hit, no IP traffic happened, thats bad,
                  this detects it and resends it, on Chrome with CORS
                  XMLHttpRequest cannot load //mtasubwaytime.info/getTime/E/G14. Request header field If-Modified-Since is not allowed by Access-Control-Allow-Headers in preflight response.
                  so include IMS header ONLY if IE with cache bug by feature test and no CORS support
                  
                  asking CORS chrome for the Date header causes "Refused to get unsafe header "Date"" and empty header value
                  which would trigger the IE 6 retry, but dont do the IE6 retry on chrome, so test first for CORS
                */
                'withCredentials' in x || x.getResponseHeader("Date")
                    ? (alertFlag?parseAlerts:parseRoutes)(x.response)
                    : getJSON(url, alertFlag, 1);
            }
            else
                alert("error HTTP status "+x.status);
    }
    /*else
        alert("currently the application is at" + invocation.readyState); */
};
        if(addIMS) x.setRequestHeader("if-modified-since", new Date(0));
        //old Firefoxes send on XHR, new FF and new Chrome send */*
        //Java EE server, if it sees "application/xml" it sends XML instead of JSON
        //"text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8"
        x.setRequestHeader("accept","application/json");
        x.send();
    //code byte savings, reuse error var
    } catch (scriptElem) { /*no CORS (old Operas, IE6 either yes/no sec warn or just works)*/
        /* alert("XHR failed-will try JSONP:\n"+e); */
        /*  opera mobile 10.00, opera desktop 10.00 1750 need cache busting
            raw button (forced download) doesnt work in updating cache */
        scriptElem = document.createElement("script");
        scriptElem.src ='//api.allorigins.win/get?url=http%3A'+escape(url+'&_=')+new Date().getTime()+'&callback='+(alertFlag?'parseAlerts':'parseRoutes');
        jsonp = document.getElementsByTagName('head')[0];
        /*dont leak mem adding infinite JSONP script elements
        this also cancels last in-progress, maybe timing out, JSONP fetch supposedly */
        if(jsonp.childNodes.length > 1)
            jsonp.removeChild(jsonp.childNodes[1]);
        jsonp.appendChild(scriptElem);
        /*document.body.appendChild(scriptElem);/*crashes on IE6 if forced JSONP mode*/
    }
}

</script></html>
<!--
JSONP innerhtml on body element/appendchild script element to body IE6 crash
>   mshtml.dll!CTreePos::SourceIndex()  + 0x3
    mshtml.dll!CMarkup::InsertElementInternal()  + 0x37b
    mshtml.dll!CDoc::InsertElement()  + 0x98
    mshtml.dll!CDocument::get_implementation()  + 0x135
    mshtml.dll!CElement::insertBefore()  + 0xd0
    mshtml.dll!CElement::appendChild()  + 0x33
    mshtml.dll!Method_IDispatchpp_IDispatchp()  + 0x60
    mshtml.dll!CBase::ContextInvokeEx()  + 0x15b
    mshtml.dll!CElement::ContextInvokeEx()  + 0x49
    mshtml.dll!CElement::ContextThunk_InvokeEx()  + 0x43
    jscript.dll!IDispatchExInvokeEx2()  + 0x6f
    jscript.dll!IDispatchExInvokeEx()  + 0x3e
    jscript.dll!InvokeDispatchEx()  + 0x78
    jscript.dll!VAR::InvokeByName()  + 0x9f0
    jscript.dll!VAR::InvokeDispName()  + 0x40
    jscript.dll!VAR::InvokeByDispID()  + 0x54
    jscript.dll!CScriptRuntime::Run()  + 0x2db0
    jscript.dll!ScrFncObj::Call()  + 0x85
    jscript.dll!CSession::Execute()  + 0x9c
    jscript.dll!NameTbl::InvokeDef()  + 0x101
    jscript.dll!NameTbl::InvokeEx()  + 0xb6
    jscript.dll!IDispatchExInvokeEx2()  + 0x6f
    jscript.dll!IDispatchExInvokeEx()  + 0x3e
    jscript.dll!NameTbl::InvokeEx()  - 0x194a0
    mshtml.dll!CScriptCollection::InvokeEx()  + 0x8f
    mshtml.dll!CWindow::InvokeEx()  + 0x2c49e
    mshtml.dll!COmWindowProxy::InvokeEx()  + 0x3379c
    mshtml.dll!COmWindowProxy::subInvokeEx()  + 0x26
    jscript.dll!IDispatchExInvokeEx2()  + 0x6f
    jscript.dll!IDispatchExInvokeEx()  + 0x3e
    jscript.dll!InvokeDispatchEx()  + 0x78
    jscript.dll!VAR::InvokeByDispID()  - 0x3b65
    jscript.dll!CScriptRuntime::Run()  + 0x2db0
    jscript.dll!ScrFncObj::Call()  + 0x85
    jscript.dll!CSession::Execute()  + 0x9c
    jscript.dll!NameTbl::InvokeDef()  + 0x101
    jscript.dll!NameTbl::InvokeEx()  + 0xb6
    mshtml.dll!CBase::InvokeDispatchWithThis()  + 0xce
    mshtml.dll!CBase::InvokeEvent()  + 0x70e2d
    mshtml.dll!CBase::FireEvent()  + 0xc5
    mshtml.dll!CElement::BubbleEventHelper()  - 0x6ed
    mshtml.dll!CElement::FireEvent()  + 0x10168
    mshtml.dll!CElement::Fire_onclick()  + 0x1c
    mshtml.dll!CElement::DoClick()  + 0x67
    mshtml.dll!CInput::DoClick()  + 0x3a
    mshtml.dll!CDoc::PumpMessage()  + 0x279b9
    mshtml.dll!CDoc::OnMouseMessage()  + 0x1a7
    mshtml.dll!CDoc::OnWindowMessage()  + 0x5a60a
    mshtml.dll!CServer::WndProc()  + 0x76
    user32.dll!_InternalCallWinProc@20()  + 0x28
    user32.dll!_UserCallWinProcCheckWow@32()  + 0xb7
    user32.dll!_DispatchMessageWorker@8()  + 0xdc
    user32.dll!_DispatchMessageW@4()  + 0xf
    browseui.dll!TimedDispatchMessage()  + 0x33
    browseui.dll!BrowserThreadProc()  + 0x336
    browseui.dll!BrowserProtectedThreadProc()  + 0x50
    browseui.dll!_SHOpenFolderWindow@4()  + 0x22c
    shdocvw.dll!_IEWinMain@8()  + 0x133
    IEXPLORE.EXE!WinMainT()  + 0x2de
    IEXPLORE.EXE!__ModuleEntry@0()  + 0x99
    kernel32.dll!_BaseProcessStart@4()  + 0x23
-->

<html>
<head>
<meta name="mobileoptimized" content="0">
<!-- put no-referrer so preload reqs match later fetch reqs instead of double req -->
<meta name="referrer" content="no-referrer">
<link href="//collector-otp-prod.camsys-apps.com/realtime/gtfsrt/ALL/alerts?type=json&apikey=qeqy84JE7hUKfaI0Lxm2Ttcm6ZA0bYrP" as="fetch" rel="preload" crossorigin>
<link href="routes.js" as="fetch" rel="preload" crossorigin>
<!-- older browsers -->
<link href="//collector-otp-prod.camsys-apps.com" rel="dns-prefetch">
<link href="//collector-otp-prod.camsys-apps.com" rel="preconnect" crossorigin>
</head>
<body>No javascript</body>
<script type="text/javascript">
/*y = getStop*/
mangleIndex={name:"mangleIndex"};
y.name = 'y';

/*
//LIRR has more routes
function AGENCY_MNR() {return 1}
function AGENCY_LI() {return 0}
function AGENCIES_MAP_RAIL() {return ['LI', 'MNR']}
//NYCT has more routes
function AGENCY_MTABC() {return 1};
function AGENCY_MTA_NYCT() {return 0};
function AGENCIES_MAP_BUS() {return ['MTA NYCT', 'MTABC']}
//
function AGENCY_MTASBWY() {return 0};
function AGENCIES_MAP_SUBWAY() {return ['MTASBWY']}
*/
var jsonp;

var url_routes =
/*STARTDELETE*/
    '//tinymta.us.to' +
/*ENDDELETE*/
'/routes.js';
var url_alerts = '//collector-otp-prod.camsys-apps.com/realtime/gtfsrt/ALL/alerts?type=json&apikey=qeqy84JE7hUKfaI0Lxm2Ttcm6ZA0bYrP';
/* on Chrome, refresh does a 200 or 304 on stop.htm on GH Pages plus MTA call
   even though if I do a "back" then navigate back to stop.htm, no TCPIP traffic
   related to stop.htm because stop.htm is fetched from browser cache, sadly there
   seems to be no way to do a refresh or a replace without triggering network traffic
   so just implement a "Fast" path that does the AJAX call alone, kindda important
   for latency reasons on 2G networks, 200 always if .reload(1),
   304 typ if .reload(0)
*/
/* generate body top string once, its later used for fast refresh */
/* var t is "top" as in top of body (header), func y() real name is getStop */
var t = '<a href=javascript:history.back()>Back</a> Refresh[<a href=javascript:y()>Fast</a> <a href=\"javascript:location.replace(\''
          +
/*STARTINSERTPATH*/
          (/status\.htm$/.test(location.pathname) ? "status_.htm" : "status.htm")
/*ENDINSERTPATH*/
          +'\')">Slow</a>] <a href='+url_routes+'>RawR</a> <a href='+url_alerts+'>RawA</a><br>';
var scriptElem;

if (this.fetch) {
  y/*getStop*/();
} else {
  scriptElem = document.createElement("script");
  scriptElem.src = 'f.js'
//    +'?a='+((new Date().getTime())+0)
  ;
//IE 5.5 and 6.0 don't have document.head
  document.documentElement.firstChild.appendChild(scriptElem);
}

/*y=getStop, must be var "y" for f.js polyfill to find and call on f.js load/exec */
function y() {
fetch(url_alerts,{},'alt').then(function(r) {
  r.status != 200 ? //put != first for r.status gzip reasons
    alert("error http status " + r.status)
  :
    r.json().then(gotAlerts);
  });
fetch(url_routes,{},'rts', 1).then(function(r) {
  r.status != 200 ? //put != first for r.status gzip reasons
    alert("error http status " + r.status)
  :
    r.text().then(gotRoutes);
  });
document.body.innerHTML = t; /*t=top*/
}

//text includes [] chars usually, if route blank, text is route
function mkSubFontTag(text, route) {
  var c =
/*STARTSUBCOLOR*/
{"4":"00933c","5":"00933c","5X":"00933c","6":"00933c","6X":"00a65c","A":"2850ad","C":"2850ad","E":"2850ad","G":"6cbe45","GS":"6d6e71","J":"996633","Z":"996633","L":"a7a9ac","7":"b933ad","7X":"b933ad","1":"ee352e","2":"ee352e","3":"ee352e","N":"fccc0a","Q":"fccc0a","R":"fccc0a","W":"fccc0a","B":"ff6319","D":"ff6319","F":"ff6319","FX":"ff6319","M":"ff6319"}
/*ENDSUBCOLOR*/
  [route||text];
  return c ?'<font color='+c+'>'+text+'</font>':text;
}

/* can't move to f.js, fetch() added in Chrome 42, Array.find in Chrome 45 */
if (!Array.prototype.find) {
  Array.prototype.find = function(callback) {
  if (this === null) {
    throw new TypeError('Array.prototype.find called on null or undefined');
  } else if (typeof callback !== 'function') {
    throw new TypeError('callback must be a function');
  }
  var list = Object(this);
  // Makes sures is always has an positive integer as length.
  var length = list.length >>> 0;
  var thisArg = arguments[1];
  for (var i = 0; i < length; i++) {
    var element = list[i];
    if ( callback.call(thisArg, element, i, list) ) {
      return element;
    }
  }
}
}

/* inlined
const BANNED_XBUS_ROUTE_TYPE = 702;
const NEW_HAVEN_BRANCHES = ['MNR:4', 'MNR:5', 'MNR:6'];
const HARLEM_BRANCHES = ['Wassaic'];
const WEIRD_RAIL_LINES = [{
  id: "MNR:Wassaic",
//  agency: "MNR",
  color: "0039A6",
// unused
//inService: true,
//mode: "RAIL",
  longName: "Wassaic",
//routeId: "MNR_Wassaic",
  routeType: 2
}]
*/

function filterCurrentStatii (statii) {
  var alertsByRoute = {}, status, isCurrent_routeId,
      mercury_alert, n, arr_activePeriod_informedEntity, period_entity, startTime_route;
  var currentTime = Math.round(Date.now() / 1000);
  // Reduce the number of statii to only those that are current
  for(var i = 0; i < statii.length; i++) {
    status = statii[i];
    isCurrent_routeId = false;

    try {
    //MNR elevators do not have .active_period member, NYCT elevators do, both no mercury alert
    //no active_period 31 records, no mercury_alert 126 records, put mercury_alert test first
      if ((mercury_alert = status.alert['transit_realtime.mercury_alert']) && status.alert.active_period
      /* b88 removed because GTFS spec says required field
        && status.alert['transit_realtime.mercury_alert'].alert_type */
        ) {
        /* <p>Exit/Entry for 3 Av will only be available from 2 PM to 10 PM on weekdays.
         at 53/lex DOES NOT HAVE A display_before_active field, this is opposite of MTA GTFS spec
         it has an alert_type of "Station Notice" */
        var hasBeforeActive = mercury_alert.hasOwnProperty('display_before_active');

        var isPlannedWork = ~status.id.indexOf('planned_work');

        if (isPlannedWork && !hasBeforeActive) {
          isCurrent_routeId = false;
        } else {
          arr_activePeriod_informedEntity = status.alert.active_period;
          for(n=0; n < arr_activePeriod_informedEntity.length; n++) {
            period_entity = arr_activePeriod_informedEntity[n];
            if (period_entity.start && !isCurrent_routeId) {
              startTime_route = period_entity.start;

              if (hasBeforeActive) {
                startTime_route = startTime_route - mercury_alert.display_before_active;
              }

              if (currentTime > startTime_route) {
                isCurrent_routeId = true;
              }

              if (period_entity.end && currentTime > period_entity.end) {
                isCurrent_routeId = false;
              }
            }
          }
        }
      }
    } catch (e) {
      console.log(e);
    }

    // add to output byRoutes hash, initial props if needed
    if (isCurrent_routeId) {
      arr_activePeriod_informedEntity = status.alert.informed_entity;
      for(n=0; n < arr_activePeriod_informedEntity.length; n++) {
        /*now entity*/
        period_entity = arr_activePeriod_informedEntity[n];
        /*now routeId*/
        isCurrent_routeId = period_entity.route_id;
        if (isCurrent_routeId) { // some alerts are "stop_id" only
          //MNR:wassaic has diff caps between alerts and routes servers
          isCurrent_routeId = isCurrent_routeId.toLowerCase();
          /*now route*/
          startTime_route = alertsByRoute[period_entity.agency_id] = alertsByRoute[period_entity.agency_id] || {};
          startTime_route = (startTime_route[isCurrent_routeId] = startTime_route[isCurrent_routeId] || []);
          startTime_route.push(status);
        }
      }
    }
  }
  return alertsByRoute;
}

function transArrToHTML(translations) {
  var en = false,
  none = false,
  translation;
  for (var i = 0; i < translations.length; i++) {
    translation = translations[i];
    if (translation.language === 'en-html')
      //note we skip if(text) anti empty string MTA logic
      return translation.text;
    else if (translation.language === 'en')
      en = translation.text;
    else if (translation.language === '')
      none = translation.text;
  }
  return en ? en : none ? none : false;
}

function noPTag(str) {
  //remove root <p> tags and double blank lines and blank lines at end of HTML string
  return str.replace(/(<p style="min-height:10px"><\/p>)|(^<p>)|((<p><\/p>|<\/p>)+$)/g,'');
}

var allRoutes;
var alertsResp;
function gotRoutes(r,jspFlag) { /*r=resp*/
  jsonp = jspFlag;
  /* routes.js is JS not JSON, to save "s on key/prop names
     JSONP polyfill and the CF Worker/JSONP proxy ignores text() vs json()
     for performance/wire size, anti-double JS eval() pases in browser
     */
  allRoutes = typeof r == 'object' ? r :eval('0,' + r);
  if (alertsResp)
    drawHTML();
}

function gotAlerts(r,jspFlag) { /*r=resp*/
  jsonp = jspFlag;
  /* filter out irrelavent future alerts, route DB not needed yet, parallelism */
  alertsResp = filterCurrentStatii(r.entity);
  if (allRoutes)
    drawHTML();
}
function drawHTML() {
function BUSROUTES() { return 0;}
function RAILLINES() { return 1;}
function SUBWAYLINES() { return 2;}

//field 1 and 3 same for bus/rail/sub, all others differ
//rail+bus is unified
function ROUTE_ID() {return 0};
function ROUTE_AGENCY() {return 2};

function ROUTE_SUB_SORTORDER() {return 1};

function ROUTE_COLOR() {return 1};
function ROUTE_NAME() {return 3};
function ROUTE_STATUSDETAILS() {return 4};

function mergeStatii (routes, alertsByRoute, agencyMap) {

  function getSummary (status) {
    var alert = "No Status Summary";

    if (status = status.alert['transit_realtime.mercury_alert']) {
      alert = status.alert_type;
    }

    return alert;
  }

  function getDescription(status) {
    if (status = status.alert.description_text) {
      return transArrToHTML(status.translation)
    }
    return false;
  };

  function getHeader (status) {
    if (status = status.alert.header_text) {
      return transArrToHTML(status.translation)
    }
    return false;
  };

  function getPriority (entity_sortorder) {
    var priority = -10;

    if (entity_sortorder = entity_sortorder['transit_realtime.mercury_entity_selector']) {
      if (entity_sortorder = entity_sortorder.sort_order) {
        priority = entity_sortorder.split(':')[2];
        priority = priority ? priority * 1 : 100;
      }
    }

    return priority;
  };

  routes.forEach(function (route) {
    var key = (""+route[ROUTE_ID()]).toLowerCase();
    var agency = agencyMap[route[ROUTE_AGENCY()] || 0];
    var alertedRoute;
    var i;
    var status;
    var duration;
    var entity;

    if ((alertedRoute = alertsByRoute[agency]) && (alertedRoute = alertedRoute[key])) {
      //convert GTFS alert structures to a friendlier alert format
      for(i = 0; i < alertedRoute.length; i++) {
        status = alertedRoute[i];
        entity = status.alert.informed_entity.find(function (entity) {
          return entity.agency_id === agency && entity.route_id.toLowerCase() === key ? 1 : 0
        });

        duration = status.alert["transit_realtime.mercury_alert"].human_readable_active_period;
        duration = duration ? transArrToHTML(duration.translation) : '';

        //reuse array from GTFS feed, dont alloc new one, saves mem
        alertedRoute[i] = { //statusItem
          statusSummary: getSummary(status),
          statusDescription: getDescription(status),
          statusTitle: getHeader(status),
          priority: getPriority(entity),
          duration: duration
        };
      }
      route[ROUTE_STATUSDETAILS()] = alertedRoute;
    }
  });

  /*MTA code originally duped the array, no point, we filter routes for display
    later on*/
  return routes;
}

/*returns an array of status category objs,
  each which has an array of lines under it*, SUBWAYS ONLY*/
function groupedLines (lines){
  var statii = {}
  var prioritizedLines = []
  var line;
  var status;
  var statusDetails;

  for (var i = 0; i < lines.length; i++){
    line = lines[i];
    // Sort statii by priority
    line[ROUTE_STATUSDETAILS()].sort(function (a,b) {
      return b.priority - a.priority
    });
    statusDetails = line[ROUTE_STATUSDETAILS()][0];
//function toDashedCase(str){
    status = statusDetails.statusSummary.toLowerCase().replace(/\s/g, '-');

    status = statii[status] = statii[status] || {
        status: statusDetails.statusSummary,
        priority: statusDetails.priority
    };

    (status.lines = status.lines || []).push(line)
  }

  for(status in statii) {
    prioritizedLines.push(statii[status])
  }

  prioritizedLines.sort(function (a,b) {
    return b.priority - a.priority
  })

  return prioritizedLines
}

function sortSubwayLines (routes) {
  routes.sort(function (rd1, rd2) {
    return rd1[ROUTE_SUB_SORTORDER()] - rd2[ROUTE_SUB_SORTORDER()]
  })
}

function SET_SUBWAY_LINES(subwayLines, goodServiceLines, subwayLinesAlertsMerged) {
  subwayLinesAlertsMerged.forEach(function (route) {
    if (route[ROUTE_STATUSDETAILS()]) {
      subwayLines.push(route)
    } else {
      goodServiceLines.push(route)
    }
  })

  sortSubwayLines(subwayLines)
  sortSubwayLines(goodServiceLines)
}
function SET_BUS_ROUTES(alertedBuses, busRoutes) {
  busRoutes.forEach(function (route) {
    if (route[ROUTE_STATUSDETAILS()]) {
      route[ROUTE_STATUSDETAILS()].sort(function (a, b) {
        return b.priority - a.priority
      })
      alertedBuses.push(route)
    }
  })
}
function SET_RAIL_LINES(mnrLines, longIslandLines, railLines) {
  railLines.forEach(function (line) {
    ( /* line.agency == AGENCY_MNR() mnr == 1 */ line[ROUTE_AGENCY()] ? mnrLines : longIslandLines
    //  : agency === 'MNR' || agency === 'NJT' ? mnrLines
    // b88 original MTA logic says maybe there are non-MTA rail lines
    // but I can't find any in real data
    //  : (function() {debugger})()
    ).push(line);
    if (line[ROUTE_STATUSDETAILS()]) {
      line[ROUTE_STATUSDETAILS()].sort(function (a, b) {
        return b.priority - a.priority
      })
    }
  })
}

function getStatus(obj) {
  if (obj[ROUTE_STATUSDETAILS()] && obj[ROUTE_STATUSDETAILS()].length) {
    // console.log('rail-line-list-vue obj.statusDetails[0].statusSummary', obj.statusDetails[0].statusSummary)
    return obj[ROUTE_STATUSDETAILS()][0].statusSummary;
  }
  //todo b88, inService is a front end MTA UI field, hard wired in front end HTML route DB to true for bus & rail
  //manually downgraded by mercury alert above, maybe remove field totally??
  //DONE
  //return obj.inService ? "On or Close" : "No Scheduled Service";
  return "On or Close";
}

function emitRRStatus(name, lines) {
  for(var statusDetail, n, i = 0; i < lines.length; i++) {
    var route = lines[i];
    var status = getStatus(route);
    var has_alert = status  != "On or Close";
    var statusDetails = '';
    if(has_alert) {
      statusDetails = route[ROUTE_STATUSDETAILS()];
      for(n = 0; n < statusDetails.length; n++) {
        statusDetail = statusDetails[n];
        statusDetails[n] = '<b>' + statusDetail.statusSummary + '</b>'
         + '<br>' + noPTag(statusDetail.statusTitle)
         + (statusDetail.duration ? '<br>' + statusDetail.duration : '')
         + '<br>' + (statusDetail.statusDescription ? noPTag(statusDetail.statusDescription) : '');
      }
      statusDetails = statusDetails.join('<hr>');
    }
    lines[i] =  '<hr>' + (has_alert ? '<details><summary>' : '') + '<font color=' + route[ROUTE_COLOR()] + '>' + (route[ROUTE_NAME()] ? route[ROUTE_NAME()] :  route[ROUTE_ID()].charAt(0) == 'B' && route[ROUTE_ID()].charAt(1) == 'X' ? "Bx"+route[ROUTE_ID()].substr(2):route[ROUTE_ID()]) + '</font>' + ' ' + status + (has_alert ? '</summary>' + statusDetails + '</details>' : '');
  }
  return '<hr>' + name + '<br>' +lines.join('');
}

      var h=(new Date()).toLocaleTimeString('en-US')+(jsonp ? ' via JSONP' : ' via CORS') + "<br>",i,linearr,route,o,n,statusDetail;
      var alertedBuses = [];
      var mnrLines = [];
      var longIslandLines = [];
      var subwayLines = [];
      var goodServiceLines = [];

      SET_SUBWAY_LINES(subwayLines, goodServiceLines, mergeStatii(allRoutes[SUBWAYLINES()], alertsResp, /*AGENCIES_MAP_SUBWAY()*/ ['MTASBWY']));
      SET_RAIL_LINES(mnrLines, longIslandLines, mergeStatii(allRoutes[RAILLINES()], alertsResp, /*AGENCIES_MAP_RAIL()*/ ['LI', 'MNR']));
      SET_BUS_ROUTES(alertedBuses, mergeStatii(allRoutes[BUSROUTES()], alertsResp, /*AGENCIES_MAP_BUS()*/ ['MTA NYCT', 'MTABC']));
      var groupedByStatusLines = groupedLines(subwayLines);

      for (i=0; i < groupedByStatusLines.length; i++) {
        linearr = groupedByStatusLines[i];
        h += '<hr>' + linearr.status + '<br>';
        linearr = linearr.lines;
        for (o=0; o < linearr.length; o++) {
          route = linearr[o];
          //if(route.name=='SI') {debugger;}
          h+='<details><summary>'+mkSubFontTag('['+route[ROUTE_ID()]+']', route[ROUTE_ID()])+'</summary>';
          //route now alerts array, overwrite status-details array of objs with string.
          route = route[ROUTE_STATUSDETAILS()];
          for (n=0; n < route.length; n++) {
            statusDetail = route[n];
            route[n] ='<b>'+statusDetail.statusSummary+'</b>'
            + '<br>' + noPTag(statusDetail.statusTitle).replace(/\[(\w+)\]/g, mkSubFontTag)
            + (statusDetail.duration ? '<br>' + statusDetail.duration : '')
            + '<br>' + (statusDetail.statusDescription ? noPTag(statusDetail.statusDescription).replace(/\[(\w+)\]/g, mkSubFontTag):'');
          }
          h += route.join('<hr>');
          h += '</details>';
        }
      }

      if(goodServiceLines.length) {
        h += '<hr>No Active Alerts<br>';
        for (i=0; i < goodServiceLines.length; i++) {
          route = goodServiceLines[i][ROUTE_ID()];
          h+=mkSubFontTag('['+route+']', route)+' ';
        }
      }

      h += emitRRStatus('Metro-North Railroad', mnrLines);
      h += emitRRStatus('Long Island Rail Road', longIslandLines);
      h += emitRRStatus('Bus', alertedBuses);

    document.body.innerHTML += h;
    alertsResp = void 0;
    allRoutes = void 0;
}
</script></html>
<!--
JSONP innerhtml on body element/appendchild script element to body IE6 crash
>   mshtml.dll!CTreePos::SourceIndex()  + 0x3
    mshtml.dll!CMarkup::InsertElementInternal()  + 0x37b
    mshtml.dll!CDoc::InsertElement()  + 0x98
    mshtml.dll!CDocument::get_implementation()  + 0x135
    mshtml.dll!CElement::insertBefore()  + 0xd0
    mshtml.dll!CElement::appendChild()  + 0x33
    mshtml.dll!Method_IDispatchpp_IDispatchp()  + 0x60
    mshtml.dll!CBase::ContextInvokeEx()  + 0x15b
    mshtml.dll!CElement::ContextInvokeEx()  + 0x49
    mshtml.dll!CElement::ContextThunk_InvokeEx()  + 0x43
    jscript.dll!IDispatchExInvokeEx2()  + 0x6f
    jscript.dll!IDispatchExInvokeEx()  + 0x3e
    jscript.dll!InvokeDispatchEx()  + 0x78
    jscript.dll!VAR::InvokeByName()  + 0x9f0
    jscript.dll!VAR::InvokeDispName()  + 0x40
    jscript.dll!VAR::InvokeByDispID()  + 0x54
    jscript.dll!CScriptRuntime::Run()  + 0x2db0
    jscript.dll!ScrFncObj::Call()  + 0x85
    jscript.dll!CSession::Execute()  + 0x9c
    jscript.dll!NameTbl::InvokeDef()  + 0x101
    jscript.dll!NameTbl::InvokeEx()  + 0xb6
    jscript.dll!IDispatchExInvokeEx2()  + 0x6f
    jscript.dll!IDispatchExInvokeEx()  + 0x3e
    jscript.dll!NameTbl::InvokeEx()  - 0x194a0
    mshtml.dll!CScriptCollection::InvokeEx()  + 0x8f
    mshtml.dll!CWindow::InvokeEx()  + 0x2c49e
    mshtml.dll!COmWindowProxy::InvokeEx()  + 0x3379c
    mshtml.dll!COmWindowProxy::subInvokeEx()  + 0x26
    jscript.dll!IDispatchExInvokeEx2()  + 0x6f
    jscript.dll!IDispatchExInvokeEx()  + 0x3e
    jscript.dll!InvokeDispatchEx()  + 0x78
    jscript.dll!VAR::InvokeByDispID()  - 0x3b65
    jscript.dll!CScriptRuntime::Run()  + 0x2db0
    jscript.dll!ScrFncObj::Call()  + 0x85
    jscript.dll!CSession::Execute()  + 0x9c
    jscript.dll!NameTbl::InvokeDef()  + 0x101
    jscript.dll!NameTbl::InvokeEx()  + 0xb6
    mshtml.dll!CBase::InvokeDispatchWithThis()  + 0xce
    mshtml.dll!CBase::InvokeEvent()  + 0x70e2d
    mshtml.dll!CBase::FireEvent()  + 0xc5
    mshtml.dll!CElement::BubbleEventHelper()  - 0x6ed
    mshtml.dll!CElement::FireEvent()  + 0x10168
    mshtml.dll!CElement::Fire_onclick()  + 0x1c
    mshtml.dll!CElement::DoClick()  + 0x67
    mshtml.dll!CInput::DoClick()  + 0x3a
    mshtml.dll!CDoc::PumpMessage()  + 0x279b9
    mshtml.dll!CDoc::OnMouseMessage()  + 0x1a7
    mshtml.dll!CDoc::OnWindowMessage()  + 0x5a60a
    mshtml.dll!CServer::WndProc()  + 0x76
    user32.dll!_InternalCallWinProc@20()  + 0x28
    user32.dll!_UserCallWinProcCheckWow@32()  + 0xb7
    user32.dll!_DispatchMessageWorker@8()  + 0xdc
    user32.dll!_DispatchMessageW@4()  + 0xf
    browseui.dll!TimedDispatchMessage()  + 0x33
    browseui.dll!BrowserThreadProc()  + 0x336
    browseui.dll!BrowserProtectedThreadProc()  + 0x50
    browseui.dll!_SHOpenFolderWindow@4()  + 0x22c
    shdocvw.dll!_IEWinMain@8()  + 0x133
    IEXPLORE.EXE!WinMainT()  + 0x2de
    IEXPLORE.EXE!__ModuleEntry@0()  + 0x99
    kernel32.dll!_BaseProcessStart@4()  + 0x23
-->
